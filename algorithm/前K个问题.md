# Top k 问题
---
---
## 1. 问题描述
对于前K个问题，描述很简单，即有一个相对较大的数据，求其中前K个大的数据，比如：
```linux
问题：当前有10w个数据，求出其中前100大的数据，或者求其中第100大的数据
```
常见解决前K个问题的主要有以下的解决方案：
- 小顶堆（求top K用小顶堆，求last K用大顶堆）
- 优先队列（本质上也是堆）
- 桶排序
- 分治法
- Bigmap


==注意：此问题的通用解法是使用**分治法**，如果数据重复性高的话可以使用bigmap==

### 数据内容
我们首先生成10w条数据，求其中前100个：
```python
def create_test_data():
    number = 100000
    return [random.randint(1, number) for i in range(number)]
```

## 2. 小顶堆
对于堆排序，堆的调整，在以下的文章中已经详细说明了，这个地方不再细说，直接使用：[堆排序说明传送门](https://blog.csdn.net/aninstein/article/details/110282314)

因为需要求取前k个最大或者最小的值，那么按照堆的性质，如果需要求找前k个最大的数据，则我们需要构建一个小顶堆，**堆顶元素就是这第k个数的最小值**.，只要这个数据比堆顶元素大，堆顶元素就应该弹出，对当前数据进行**自顶向下**操作，得到的**新的堆顶元素就是这第k个数的新最小值**。
 
构建一个长度为k的堆，然后使用data里面的数据遍历的与这个堆的堆顶元素进行比较，如果大于堆顶元素，则弹出堆顶，当前值换到堆顶元素上，并且进行**自顶向下**的堆调整，**即进行一次堆的插入操作**

然后求解前k个数据的问题：
```python
def top_k_to_heap(data, k):
    """
    前k个问题
    问题描述：当前有100000个数据，求出其中前100大的数据，或者求其中第100大的数据
    1. 如果求前k大，则构造小顶堆
    2. 如果求前k小，则构建大顶堆
    3. 比较堆顶元素，因为堆顶元素就是第k个元素

    本题求解的是第K个大的问题
    :param data: 数据集合
    :param k: k的长度
    :return:
    """
    if not data:
        data = create_test_data()

    # 构建一个长度为k的堆
    heap_data = make_heap(data[:k])

    # 对剩余数据，与堆顶元素比较
    for i in range(k, len(data)):
        num = data[i]
        if num < heap_data[0]:  # 不能等于，因为前k个可能有重复的
            continue
        heap_data[0] = num
        min_adjust_heap_top2down(heap_data, 0)
    return heap_data
```
当然，为了节省时间，这个地方就用100条数据前10个当作测试了，输出结果：
```linux
big data:  [40, 93, 57, 25, 85, 12, 95, 33, 88, 86, 75, 58, 28, 58, 20, 23, 33, 52, 87, 77, 30, 84, 18, 26, 27, 45, 39, 32, 6, 73, 28, 68, 94, 14, 48, 8, 88, 57, 88, 43, 83, 67, 26, 54, 70, 71, 46, 91, 47, 58, 90, 95, 2, 85, 65, 84, 85, 48, 34, 18, 39, 31, 77, 21, 31, 77, 45, 55, 8, 6, 77, 99, 95, 85, 31, 80, 62, 85, 96, 24, 16, 65, 35, 97, 46, 26, 52, 32, 43, 23, 96, 77, 24, 82, 72, 23, 21, 86, 4, 95]
big data sort:  [99, 97, 96, 96, 95, 95, 95, 95, 94, 93, 91, 90, 88, 88, 88, 87, 86, 86, 85, 85, 85, 85, 85, 84, 84, 83, 82, 80, 77, 77, 77, 77, 77, 75, 73, 72, 71, 70, 68, 67, 65, 65, 62, 58, 58, 58, 57, 57, 55, 54, 52, 52, 48, 48, 47, 46, 46, 45, 45, 43, 43, 40, 39, 39, 35, 34, 33, 33, 32, 32, 31, 31, 31, 30, 28, 28, 27, 26, 26, 26, 25, 24, 24, 23, 23, 23, 21, 21, 20, 18, 18, 16, 14, 12, 8, 8, 6, 6, 4, 2]
res data sort:  [99, 97, 96, 96, 95, 95, 95, 95, 94, 93]
```

## 3. 优先队列（本质也是堆）
我们可以使用优先队列解决这个问题，优先队列本质上也是堆，优先级队列是不同于先进先出队列的另一种队列。每次从队列中取出的是具有**最高优先权的元素**。

在我们说堆的存储当中，一般使用数组来存储堆，即对于小顶堆：
```
           1
         /   \
        2     3
      /  \   /  \
     4    5 6    7     
```
我们可以表示为：
```
min_heap = [1, 2, 3, 4, 5, 6, 7]
```
而对于**优先队列，它的最高权值即小顶堆的堆顶元素，可以认为优先队列的权值是按照小顶堆的下标决定的。**，所以如果我们往队列中存入：[1, 3, 5, 10, 2]，自动会被排列[1, 2, 3, 5, 10]

不同语言使用了一些包可以直接调度用优先队列，比如java的import java.util.PriorityQueue，python的import heapq。这里使用heapq。
```python
def top_k_to_priority_queue(data, k):
    """
    优先队列
    :param data:
    :param k:
    :return:
    """
    if not data:
        data = create_test_data()

    queue = []
    for i in range(k):
        heapq.heappush(queue, data[i])

    for i in range(k, len(data)):
        num = data[i]
        if num < queue[0]:
            continue
        heapq.heappop(queue)
        heapq.heappush(queue, num)
    return queue
```
同样，为了节省时间，这个地方就用100条数据前10个当作测试了，输出结果：
```linux
big data:  [3, 36, 72, 15, 50, 91, 45, 7, 18, 59, 48, 69, 66, 19, 92, 99, 48, 42, 21, 7, 100, 18, 21, 100, 18, 84, 89, 38, 97, 58, 30, 35, 33, 70, 48, 66, 99, 82, 73, 86, 80, 68, 82, 80, 20, 57, 33, 96, 87, 61, 6, 87, 3, 34, 32, 96, 96, 27, 92, 1, 77, 52, 82, 10, 98, 32, 62, 4, 87, 37, 41, 94, 12, 95, 38, 6, 56, 26, 53, 41, 23, 59, 24, 59, 29, 80, 13, 48, 47, 77, 89, 97, 33, 22, 2, 63, 42, 22, 60, 10]

res data sort: [96, 96, 97, 99, 96, 98, 99, 100, 100, 97]
```

## 4. 桶排序
使用桶排序完成前K个问题很，只是在数据比较分散，或者数据内容主要集中在高部才能够比较好排序效率，使用桶排序的求前K个问题步骤：
1. 先按照当前数据范围进行分桶
2. 遍历数据，进行数据落桶
3. 计算每个桶中数据的数量，当第一个桶数据量小于K，继续到下一个桶
4. 直到加上某一个桶中的数据超过了K值，这时候再对这个桶中的数据进行桶排序，重复1-3的流程
5. 最后到桶排序的数据量到一个较小的可控范围（100左右）的时候，直接使用其他的比较排序法取得前K个

## 5. 分治法
## 6. BigMap